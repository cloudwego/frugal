/*
 * Copyright 2024 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by thriftgo (0.3.18) (fastgo). DO NOT EDIT.
package baseline

import (
	"fmt"

	"github.com/cloudwego/gopkg/protocol/thrift"
)

func (p *Simple) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.ByteField ID:1 thrift.I08
	off += 3
	off += 1

	// p.I64Field ID:2 thrift.I64
	off += 3
	off += 8

	// p.DoubleField ID:3 thrift.DOUBLE
	off += 3
	off += 8

	// p.I32Field ID:4 thrift.I32
	off += 3
	off += 4

	// p.StringField ID:5 thrift.STRING
	off += 3
	off += 4 + len(p.StringField)

	// p.BinaryField ID:6 thrift.STRING
	off += 3
	off += 4 + len(p.BinaryField)

	// p.EnumField ID:7 thrift.I32
	off += 3
	off += 4
	return off + 1
}

func (p *Simple) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Simple) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Simple) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.ByteField
	b = append(b, 3, 0, 1)
	b = append(b, byte(p.ByteField))

	// p.I64Field
	b = append(b, 10, 0, 2)
	b = x.AppendI64(b, int64(p.I64Field))

	// p.DoubleField
	b = append(b, 4, 0, 3)
	b = x.AppendDouble(b, float64(p.DoubleField))

	// p.I32Field
	b = append(b, 8, 0, 4)
	b = x.AppendI32(b, int32(p.I32Field))

	// p.StringField
	b = append(b, 11, 0, 5)
	b = x.AppendI32(b, int32(len(p.StringField)))
	b = append(b, p.StringField...)

	// p.BinaryField
	b = append(b, 11, 0, 6)
	b = x.AppendI32(b, int32(len(p.BinaryField)))
	b = append(b, p.BinaryField...)

	// p.EnumField
	b = append(b, 8, 0, 7)
	b = x.AppendI32(b, int32(p.EnumField))

	return append(b, 0)
}

func (p *Simple) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	var enum int32
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x103: // p.ByteField ID:1 thrift.I08
			p.ByteField, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20a: // p.I64Field ID:2 thrift.I64
			p.I64Field, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x304: // p.DoubleField ID:3 thrift.DOUBLE
			p.DoubleField, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x408: // p.I32Field ID:4 thrift.I32
			p.I32Field, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50b: // p.StringField ID:5 thrift.STRING
			p.StringField, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x60b: // p.BinaryField ID:6 thrift.STRING
			p.BinaryField, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x708: // p.EnumField ID:7 thrift.I32
			enum, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.EnumField = Enums(enum)
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Simple[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Nesting) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.String_ ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.String_)

	// p.ListSimple ID:2 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.ListSimple {
		off += v.BLength()
	}

	// p.Double ID:3 thrift.DOUBLE
	off += 3
	off += 8

	// p.I32 ID:4 thrift.I32
	off += 3
	off += 4

	// p.ListI32 ID:5 thrift.LIST
	off += 3
	off += 5
	off += len(p.ListI32) * 4

	// p.I64 ID:6 thrift.I64
	off += 3
	off += 8

	// p.MapStringString ID:7 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapStringString {
		off += 4 + len(k)
		off += 4 + len(v)
	}

	// p.SimpleStruct ID:8 thrift.STRUCT
	off += 3
	off += p.SimpleStruct.BLength()

	// p.MapI32I64 ID:9 thrift.MAP
	off += 3
	off += 6
	off += len(p.MapI32I64) * (4 + 8)

	// p.ListString ID:10 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.ListString {
		off += 4 + len(v)
	}

	// p.Binary ID:11 thrift.STRING
	off += 3
	off += 4 + len(p.Binary)

	// p.MapI64String ID:12 thrift.MAP
	off += 3
	off += 6
	off += len(p.MapI64String) * 8
	for _, v := range p.MapI64String {
		off += 4 + len(v)
	}

	// p.ListI64 ID:13 thrift.LIST
	off += 3
	off += 5
	off += len(p.ListI64) * 8

	// p.Byte ID:14 thrift.I08
	off += 3
	off += 1

	// p.MapStringSimple ID:15 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapStringSimple {
		off += 4 + len(k)
		off += v.BLength()
	}
	return off + 1
}

func (p *Nesting) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Nesting) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Nesting) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.String_
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.String_)))
	b = append(b, p.String_...)

	// p.ListSimple
	b = append(b, 15, 0, 2)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.ListSimple))
	for _, v := range p.ListSimple {
		b = v.FastAppend(b)
	}

	// p.Double
	b = append(b, 4, 0, 3)
	b = x.AppendDouble(b, float64(p.Double))

	// p.I32
	b = append(b, 8, 0, 4)
	b = x.AppendI32(b, int32(p.I32))

	// p.ListI32
	b = append(b, 15, 0, 5)
	b = x.AppendListBegin(b, thrift.I32, len(p.ListI32))
	for _, v := range p.ListI32 {
		b = x.AppendI32(b, int32(v))
	}

	// p.I64
	b = append(b, 10, 0, 6)
	b = x.AppendI64(b, int64(p.I64))

	// p.MapStringString
	b = append(b, 13, 0, 7)
	b = x.AppendMapBegin(b, thrift.STRING, thrift.STRING, len(p.MapStringString))
	for k, v := range p.MapStringString {
		b = x.AppendI32(b, int32(len(k)))
		b = append(b, k...)
		b = x.AppendI32(b, int32(len(v)))
		b = append(b, v...)
	}

	// p.SimpleStruct
	b = append(b, 12, 0, 8)
	b = p.SimpleStruct.FastAppend(b)

	// p.MapI32I64
	b = append(b, 13, 0, 9)
	b = x.AppendMapBegin(b, thrift.I32, thrift.I64, len(p.MapI32I64))
	for k, v := range p.MapI32I64 {
		b = x.AppendI32(b, int32(k))
		b = x.AppendI64(b, int64(v))
	}

	// p.ListString
	b = append(b, 15, 0, 10)
	b = x.AppendListBegin(b, thrift.STRING, len(p.ListString))
	for _, v := range p.ListString {
		b = x.AppendI32(b, int32(len(v)))
		b = append(b, v...)
	}

	// p.Binary
	b = append(b, 11, 0, 11)
	b = x.AppendI32(b, int32(len(p.Binary)))
	b = append(b, p.Binary...)

	// p.MapI64String
	b = append(b, 13, 0, 12)
	b = x.AppendMapBegin(b, thrift.I64, thrift.STRING, len(p.MapI64String))
	for k, v := range p.MapI64String {
		b = x.AppendI64(b, int64(k))
		b = x.AppendI32(b, int32(len(v)))
		b = append(b, v...)
	}

	// p.ListI64
	b = append(b, 15, 0, 13)
	b = x.AppendListBegin(b, thrift.I64, len(p.ListI64))
	for _, v := range p.ListI64 {
		b = x.AppendI64(b, int64(v))
	}

	// p.Byte
	b = append(b, 3, 0, 14)
	b = append(b, byte(p.Byte))

	// p.MapStringSimple
	b = append(b, 13, 0, 15)
	b = x.AppendMapBegin(b, thrift.STRING, thrift.STRUCT, len(p.MapStringSimple))
	for k, v := range p.MapStringSimple {
		b = x.AppendI32(b, int32(len(k)))
		b = append(b, k...)
		b = v.FastAppend(b)
	}

	return append(b, 0)
}

func (p *Nesting) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.String_ ID:1 thrift.STRING
			p.String_, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20f: // p.ListSimple ID:2 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListSimple = make([]*Simple, sz)
			for i := 0; i < sz; i++ {
				p.ListSimple[i] = NewSimple()
				l, err = p.ListSimple[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x304: // p.Double ID:3 thrift.DOUBLE
			p.Double, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x408: // p.I32 ID:4 thrift.I32
			p.I32, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50f: // p.ListI32 ID:5 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListI32 = make([]int32, sz)
			for i := 0; i < sz; i++ {
				p.ListI32[i], l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x60a: // p.I64 ID:6 thrift.I64
			p.I64, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x70d: // p.MapStringString ID:7 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringString = make(map[string]string, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v string
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringString[k] = v
			}
		case 0x80c: // p.SimpleStruct ID:8 thrift.STRUCT
			p.SimpleStruct = NewSimple()
			l, err = p.SimpleStruct.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x90d: // p.MapI32I64 ID:9 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapI32I64 = make(map[int32]int64, sz)
			for i := 0; i < sz; i++ {
				var k int32
				var v int64
				k, l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapI32I64[k] = v
			}
		case 0xa0f: // p.ListString ID:10 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListString = make([]string, sz)
			for i := 0; i < sz; i++ {
				p.ListString[i], l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xb0b: // p.Binary ID:11 thrift.STRING
			p.Binary, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0xc0d: // p.MapI64String ID:12 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapI64String = make(map[int64]string, sz)
			for i := 0; i < sz; i++ {
				var k int64
				var v string
				k, l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapI64String[k] = v
			}
		case 0xd0f: // p.ListI64 ID:13 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListI64 = make([]int64, sz)
			for i := 0; i < sz; i++ {
				p.ListI64[i], l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xe03: // p.Byte ID:14 thrift.I08
			p.Byte, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0xf0d: // p.MapStringSimple ID:15 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringSimple = make(map[string]*Simple, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v *Simple
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v = NewSimple()
				l, err = v.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringSimple[k] = v
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Nesting[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Nesting2) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.MapSimpleNesting ID:1 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapSimpleNesting {
		off += k.BLength()
		off += v.BLength()
	}

	// p.SimpleStruct ID:2 thrift.STRUCT
	off += 3
	off += p.SimpleStruct.BLength()

	// p.Byte ID:3 thrift.I08
	off += 3
	off += 1

	// p.Double ID:4 thrift.DOUBLE
	off += 3
	off += 8

	// p.ListNesting ID:5 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.ListNesting {
		off += v.BLength()
	}

	// p.I64 ID:6 thrift.I64
	off += 3
	off += 8

	// p.NestingStruct ID:7 thrift.STRUCT
	off += 3
	off += p.NestingStruct.BLength()

	// p.Binary ID:8 thrift.STRING
	off += 3
	off += 4 + len(p.Binary)

	// p.String_ ID:9 thrift.STRING
	off += 3
	off += 4 + len(p.String_)

	// p.SetNesting ID:10 thrift.SET
	off += 3
	off += 5
	for _, v := range p.SetNesting {
		off += v.BLength()
	}

	// p.I32 ID:11 thrift.I32
	off += 3
	off += 4
	return off + 1
}

func (p *Nesting2) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Nesting2) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Nesting2) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.MapSimpleNesting
	b = append(b, 13, 0, 1)
	b = x.AppendMapBegin(b, thrift.STRUCT, thrift.STRUCT, len(p.MapSimpleNesting))
	for k, v := range p.MapSimpleNesting {
		b = k.FastAppend(b)
		b = v.FastAppend(b)
	}

	// p.SimpleStruct
	b = append(b, 12, 0, 2)
	b = p.SimpleStruct.FastAppend(b)

	// p.Byte
	b = append(b, 3, 0, 3)
	b = append(b, byte(p.Byte))

	// p.Double
	b = append(b, 4, 0, 4)
	b = x.AppendDouble(b, float64(p.Double))

	// p.ListNesting
	b = append(b, 15, 0, 5)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.ListNesting))
	for _, v := range p.ListNesting {
		b = v.FastAppend(b)
	}

	// p.I64
	b = append(b, 10, 0, 6)
	b = x.AppendI64(b, int64(p.I64))

	// p.NestingStruct
	b = append(b, 12, 0, 7)
	b = p.NestingStruct.FastAppend(b)

	// p.Binary
	b = append(b, 11, 0, 8)
	b = x.AppendI32(b, int32(len(p.Binary)))
	b = append(b, p.Binary...)

	// p.String_
	b = append(b, 11, 0, 9)
	b = x.AppendI32(b, int32(len(p.String_)))
	b = append(b, p.String_...)

	// p.SetNesting
	b = append(b, 14, 0, 10)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.SetNesting))
	for _, v := range p.SetNesting {
		b = v.FastAppend(b)
	}

	// p.I32
	b = append(b, 8, 0, 11)
	b = x.AppendI32(b, int32(p.I32))

	return append(b, 0)
}

func (p *Nesting2) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10d: // p.MapSimpleNesting ID:1 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapSimpleNesting = make(map[*Simple]*Nesting, sz)
			for i := 0; i < sz; i++ {
				var k *Simple
				var v *Nesting
				k = NewSimple()
				l, err = k.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v = NewNesting()
				l, err = v.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapSimpleNesting[k] = v
			}
		case 0x20c: // p.SimpleStruct ID:2 thrift.STRUCT
			p.SimpleStruct = NewSimple()
			l, err = p.SimpleStruct.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x303: // p.Byte ID:3 thrift.I08
			p.Byte, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x404: // p.Double ID:4 thrift.DOUBLE
			p.Double, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50f: // p.ListNesting ID:5 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListNesting = make([]*Nesting, sz)
			for i := 0; i < sz; i++ {
				p.ListNesting[i] = NewNesting()
				l, err = p.ListNesting[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x60a: // p.I64 ID:6 thrift.I64
			p.I64, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x70c: // p.NestingStruct ID:7 thrift.STRUCT
			p.NestingStruct = NewNesting()
			l, err = p.NestingStruct.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x80b: // p.Binary ID:8 thrift.STRING
			p.Binary, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x90b: // p.String_ ID:9 thrift.STRING
			p.String_, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0xa0e: // p.SetNesting ID:10 thrift.SET
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.SetNesting = make([]*Nesting, sz)
			for i := 0; i < sz; i++ {
				p.SetNesting[i] = NewNesting()
				l, err = p.SetNesting[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xb08: // p.I32 ID:11 thrift.I32
			p.I32, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Nesting2[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *DefaultValues) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.ByteFieldWithDefault ID:1 thrift.I08
	off += 3
	off += 1

	// p.I64FieldWithDefault ID:2 thrift.I64
	off += 3
	off += 8

	// p.DoubleFieldWithDefault ID:3 thrift.DOUBLE
	off += 3
	off += 8

	// p.I32FieldWithDefault ID:4 thrift.I32
	off += 3
	off += 4

	// p.StringFieldWithDefault ID:5 thrift.STRING
	off += 3
	off += 4 + len(p.StringFieldWithDefault)

	// p.BinaryFieldWithDefault ID:6 thrift.STRING
	off += 3
	off += 4 + len(p.BinaryFieldWithDefault)

	// p.EnumFieldWithDefault ID:7 thrift.I32
	off += 3
	off += 4

	// p.SimpleStructWithDefault ID:8 thrift.STRUCT
	off += 3
	off += p.SimpleStructWithDefault.BLength()

	// p.ListFieldWithDefault ID:9 thrift.LIST
	off += 3
	off += 5
	off += len(p.ListFieldWithDefault) * 4

	// p.SetFieldWithDefault ID:10 thrift.SET
	off += 3
	off += 5
	off += len(p.SetFieldWithDefault) * 4

	// p.MapI32I64WithDefault ID:11 thrift.MAP
	off += 3
	off += 6
	off += len(p.MapI32I64WithDefault) * (4 + 8)

	// p.MapI64StringWithDefault ID:12 thrift.MAP
	off += 3
	off += 6
	off += len(p.MapI64StringWithDefault) * 8
	for _, v := range p.MapI64StringWithDefault {
		off += 4 + len(v)
	}

	// p.MapStringStringWithDefault ID:13 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapStringStringWithDefault {
		off += 4 + len(k)
		off += 4 + len(v)
	}

	// p.MapStringSimpleWithDefault ID:14 thrift.MAP
	off += 3
	off += 6
	for k, v := range p.MapStringSimpleWithDefault {
		off += 4 + len(k)
		off += v.BLength()
	}
	return off + 1
}

func (p *DefaultValues) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *DefaultValues) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *DefaultValues) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.ByteFieldWithDefault
	b = append(b, 3, 0, 1)
	b = append(b, byte(p.ByteFieldWithDefault))

	// p.I64FieldWithDefault
	b = append(b, 10, 0, 2)
	b = x.AppendI64(b, int64(p.I64FieldWithDefault))

	// p.DoubleFieldWithDefault
	b = append(b, 4, 0, 3)
	b = x.AppendDouble(b, float64(p.DoubleFieldWithDefault))

	// p.I32FieldWithDefault
	b = append(b, 8, 0, 4)
	b = x.AppendI32(b, int32(p.I32FieldWithDefault))

	// p.StringFieldWithDefault
	b = append(b, 11, 0, 5)
	b = x.AppendI32(b, int32(len(p.StringFieldWithDefault)))
	b = append(b, p.StringFieldWithDefault...)

	// p.BinaryFieldWithDefault
	b = append(b, 11, 0, 6)
	b = x.AppendI32(b, int32(len(p.BinaryFieldWithDefault)))
	b = append(b, p.BinaryFieldWithDefault...)

	// p.EnumFieldWithDefault
	b = append(b, 8, 0, 7)
	b = x.AppendI32(b, int32(p.EnumFieldWithDefault))

	// p.SimpleStructWithDefault
	b = append(b, 12, 0, 8)
	b = p.SimpleStructWithDefault.FastAppend(b)

	// p.ListFieldWithDefault
	b = append(b, 15, 0, 9)
	b = x.AppendListBegin(b, thrift.I32, len(p.ListFieldWithDefault))
	for _, v := range p.ListFieldWithDefault {
		b = x.AppendI32(b, int32(v))
	}

	// p.SetFieldWithDefault
	b = append(b, 14, 0, 10)
	b = x.AppendListBegin(b, thrift.I32, len(p.SetFieldWithDefault))
	for _, v := range p.SetFieldWithDefault {
		b = x.AppendI32(b, int32(v))
	}

	// p.MapI32I64WithDefault
	b = append(b, 13, 0, 11)
	b = x.AppendMapBegin(b, thrift.I32, thrift.I64, len(p.MapI32I64WithDefault))
	for k, v := range p.MapI32I64WithDefault {
		b = x.AppendI32(b, int32(k))
		b = x.AppendI64(b, int64(v))
	}

	// p.MapI64StringWithDefault
	b = append(b, 13, 0, 12)
	b = x.AppendMapBegin(b, thrift.I64, thrift.STRING, len(p.MapI64StringWithDefault))
	for k, v := range p.MapI64StringWithDefault {
		b = x.AppendI64(b, int64(k))
		b = x.AppendI32(b, int32(len(v)))
		b = append(b, v...)
	}

	// p.MapStringStringWithDefault
	b = append(b, 13, 0, 13)
	b = x.AppendMapBegin(b, thrift.STRING, thrift.STRING, len(p.MapStringStringWithDefault))
	for k, v := range p.MapStringStringWithDefault {
		b = x.AppendI32(b, int32(len(k)))
		b = append(b, k...)
		b = x.AppendI32(b, int32(len(v)))
		b = append(b, v...)
	}

	// p.MapStringSimpleWithDefault
	b = append(b, 13, 0, 14)
	b = x.AppendMapBegin(b, thrift.STRING, thrift.STRUCT, len(p.MapStringSimpleWithDefault))
	for k, v := range p.MapStringSimpleWithDefault {
		b = x.AppendI32(b, int32(len(k)))
		b = append(b, k...)
		b = v.FastAppend(b)
	}

	return append(b, 0)
}

func (p *DefaultValues) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	var enum int32
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x103: // p.ByteFieldWithDefault ID:1 thrift.I08
			p.ByteFieldWithDefault, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20a: // p.I64FieldWithDefault ID:2 thrift.I64
			p.I64FieldWithDefault, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x304: // p.DoubleFieldWithDefault ID:3 thrift.DOUBLE
			p.DoubleFieldWithDefault, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x408: // p.I32FieldWithDefault ID:4 thrift.I32
			p.I32FieldWithDefault, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50b: // p.StringFieldWithDefault ID:5 thrift.STRING
			p.StringFieldWithDefault, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x60b: // p.BinaryFieldWithDefault ID:6 thrift.STRING
			p.BinaryFieldWithDefault, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x708: // p.EnumFieldWithDefault ID:7 thrift.I32
			enum, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.EnumFieldWithDefault = Enums(enum)
		case 0x80c: // p.SimpleStructWithDefault ID:8 thrift.STRUCT
			p.SimpleStructWithDefault = NewSimple()
			l, err = p.SimpleStructWithDefault.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x90f: // p.ListFieldWithDefault ID:9 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListFieldWithDefault = make([]int32, sz)
			for i := 0; i < sz; i++ {
				p.ListFieldWithDefault[i], l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xa0e: // p.SetFieldWithDefault ID:10 thrift.SET
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.SetFieldWithDefault = make([]int32, sz)
			for i := 0; i < sz; i++ {
				p.SetFieldWithDefault[i], l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xb0d: // p.MapI32I64WithDefault ID:11 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapI32I64WithDefault = make(map[int32]int64, sz)
			for i := 0; i < sz; i++ {
				var k int32
				var v int64
				k, l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapI32I64WithDefault[k] = v
			}
		case 0xc0d: // p.MapI64StringWithDefault ID:12 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapI64StringWithDefault = make(map[int64]string, sz)
			for i := 0; i < sz; i++ {
				var k int64
				var v string
				k, l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapI64StringWithDefault[k] = v
			}
		case 0xd0d: // p.MapStringStringWithDefault ID:13 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringStringWithDefault = make(map[string]string, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v string
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringStringWithDefault[k] = v
			}
		case 0xe0d: // p.MapStringSimpleWithDefault ID:14 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringSimpleWithDefault = make(map[string]*Simple, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v *Simple
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v = NewSimple()
				l, err = v.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringSimpleWithDefault[k] = v
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_DefaultValues[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *OptionalDefaultValues) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.ByteFieldWithDefault ID:1 thrift.I08
	if p.ByteFieldWithDefault != 1 {
		off += 3
		off += 1
	}

	// p.I64FieldWithDefault ID:2 thrift.I64
	if p.I64FieldWithDefault != 2 {
		off += 3
		off += 8
	}

	// p.DoubleFieldWithDefault ID:3 thrift.DOUBLE
	if p.DoubleFieldWithDefault != 3.0 {
		off += 3
		off += 8
	}

	// p.I32FieldWithDefault ID:4 thrift.I32
	if p.I32FieldWithDefault != 4 {
		off += 3
		off += 4
	}

	// p.StringFieldWithDefault ID:5 thrift.STRING
	if p.StringFieldWithDefault != "string field default text" {
		off += 3
		off += 4 + len(p.StringFieldWithDefault)
	}

	// p.BinaryFieldWithDefault ID:6 thrift.STRING
	if p.BinaryFieldWithDefault != nil {
		off += 3
		off += 4 + len(p.BinaryFieldWithDefault)
	}

	// p.EnumFieldWithDefault ID:7 thrift.I32
	if p.EnumFieldWithDefault != Enums_ValueA {
		off += 3
		off += 4
	}

	// p.SimpleStructWithDefault ID:8 thrift.STRUCT
	if p.SimpleStructWithDefault != nil {
		off += 3
		off += p.SimpleStructWithDefault.BLength()
	}

	// p.ListFieldWithDefault ID:9 thrift.LIST
	if p.ListFieldWithDefault != nil {
		off += 3
		off += 5
		off += len(p.ListFieldWithDefault) * 4
	}

	// p.SetFieldWithDefault ID:10 thrift.SET
	if p.SetFieldWithDefault != nil {
		off += 3
		off += 5
		off += len(p.SetFieldWithDefault) * 4
	}

	// p.MapI32I64WithDefault ID:11 thrift.MAP
	if p.MapI32I64WithDefault != nil {
		off += 3
		off += 6
		off += len(p.MapI32I64WithDefault) * (4 + 8)
	}

	// p.MapI64StringWithDefault ID:12 thrift.MAP
	if p.MapI64StringWithDefault != nil {
		off += 3
		off += 6
		off += len(p.MapI64StringWithDefault) * 8
		for _, v := range p.MapI64StringWithDefault {
			off += 4 + len(v)
		}
	}

	// p.MapStringStringWithDefault ID:13 thrift.MAP
	if p.MapStringStringWithDefault != nil {
		off += 3
		off += 6
		for k, v := range p.MapStringStringWithDefault {
			off += 4 + len(k)
			off += 4 + len(v)
		}
	}

	// p.MapStringSimpleWithDefault ID:14 thrift.MAP
	if p.MapStringSimpleWithDefault != nil {
		off += 3
		off += 6
		for k, v := range p.MapStringSimpleWithDefault {
			off += 4 + len(k)
			off += v.BLength()
		}
	}
	return off + 1
}

func (p *OptionalDefaultValues) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *OptionalDefaultValues) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *OptionalDefaultValues) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.ByteFieldWithDefault
	if p.ByteFieldWithDefault != 1 {
		b = append(b, 3, 0, 1)
		b = append(b, byte(p.ByteFieldWithDefault))
	}

	// p.I64FieldWithDefault
	if p.I64FieldWithDefault != 2 {
		b = append(b, 10, 0, 2)
		b = x.AppendI64(b, int64(p.I64FieldWithDefault))
	}

	// p.DoubleFieldWithDefault
	if p.DoubleFieldWithDefault != 3.0 {
		b = append(b, 4, 0, 3)
		b = x.AppendDouble(b, float64(p.DoubleFieldWithDefault))
	}

	// p.I32FieldWithDefault
	if p.I32FieldWithDefault != 4 {
		b = append(b, 8, 0, 4)
		b = x.AppendI32(b, int32(p.I32FieldWithDefault))
	}

	// p.StringFieldWithDefault
	if p.StringFieldWithDefault != "string field default text" {
		b = append(b, 11, 0, 5)
		b = x.AppendI32(b, int32(len(p.StringFieldWithDefault)))
		b = append(b, p.StringFieldWithDefault...)
	}

	// p.BinaryFieldWithDefault
	if p.BinaryFieldWithDefault != nil {
		b = append(b, 11, 0, 6)
		b = x.AppendI32(b, int32(len(p.BinaryFieldWithDefault)))
		b = append(b, p.BinaryFieldWithDefault...)
	}

	// p.EnumFieldWithDefault
	if p.EnumFieldWithDefault != Enums_ValueA {
		b = append(b, 8, 0, 7)
		b = x.AppendI32(b, int32(p.EnumFieldWithDefault))
	}

	// p.SimpleStructWithDefault
	if p.SimpleStructWithDefault != nil {
		b = append(b, 12, 0, 8)
		b = p.SimpleStructWithDefault.FastAppend(b)
	}

	// p.ListFieldWithDefault
	if p.ListFieldWithDefault != nil {
		b = append(b, 15, 0, 9)
		b = x.AppendListBegin(b, thrift.I32, len(p.ListFieldWithDefault))
		for _, v := range p.ListFieldWithDefault {
			b = x.AppendI32(b, int32(v))
		}
	}

	// p.SetFieldWithDefault
	if p.SetFieldWithDefault != nil {
		b = append(b, 14, 0, 10)
		b = x.AppendListBegin(b, thrift.I32, len(p.SetFieldWithDefault))
		for _, v := range p.SetFieldWithDefault {
			b = x.AppendI32(b, int32(v))
		}
	}

	// p.MapI32I64WithDefault
	if p.MapI32I64WithDefault != nil {
		b = append(b, 13, 0, 11)
		b = x.AppendMapBegin(b, thrift.I32, thrift.I64, len(p.MapI32I64WithDefault))
		for k, v := range p.MapI32I64WithDefault {
			b = x.AppendI32(b, int32(k))
			b = x.AppendI64(b, int64(v))
		}
	}

	// p.MapI64StringWithDefault
	if p.MapI64StringWithDefault != nil {
		b = append(b, 13, 0, 12)
		b = x.AppendMapBegin(b, thrift.I64, thrift.STRING, len(p.MapI64StringWithDefault))
		for k, v := range p.MapI64StringWithDefault {
			b = x.AppendI64(b, int64(k))
			b = x.AppendI32(b, int32(len(v)))
			b = append(b, v...)
		}
	}

	// p.MapStringStringWithDefault
	if p.MapStringStringWithDefault != nil {
		b = append(b, 13, 0, 13)
		b = x.AppendMapBegin(b, thrift.STRING, thrift.STRING, len(p.MapStringStringWithDefault))
		for k, v := range p.MapStringStringWithDefault {
			b = x.AppendI32(b, int32(len(k)))
			b = append(b, k...)
			b = x.AppendI32(b, int32(len(v)))
			b = append(b, v...)
		}
	}

	// p.MapStringSimpleWithDefault
	if p.MapStringSimpleWithDefault != nil {
		b = append(b, 13, 0, 14)
		b = x.AppendMapBegin(b, thrift.STRING, thrift.STRUCT, len(p.MapStringSimpleWithDefault))
		for k, v := range p.MapStringSimpleWithDefault {
			b = x.AppendI32(b, int32(len(k)))
			b = append(b, k...)
			b = v.FastAppend(b)
		}
	}

	return append(b, 0)
}

func (p *OptionalDefaultValues) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	var enum int32
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x103: // p.ByteFieldWithDefault ID:1 thrift.I08
			p.ByteFieldWithDefault, l, err = x.ReadByte(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20a: // p.I64FieldWithDefault ID:2 thrift.I64
			p.I64FieldWithDefault, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x304: // p.DoubleFieldWithDefault ID:3 thrift.DOUBLE
			p.DoubleFieldWithDefault, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x408: // p.I32FieldWithDefault ID:4 thrift.I32
			p.I32FieldWithDefault, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50b: // p.StringFieldWithDefault ID:5 thrift.STRING
			p.StringFieldWithDefault, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x60b: // p.BinaryFieldWithDefault ID:6 thrift.STRING
			p.BinaryFieldWithDefault, l, err = x.ReadBinary(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x708: // p.EnumFieldWithDefault ID:7 thrift.I32
			enum, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.EnumFieldWithDefault = Enums(enum)
		case 0x80c: // p.SimpleStructWithDefault ID:8 thrift.STRUCT
			p.SimpleStructWithDefault = NewSimple()
			l, err = p.SimpleStructWithDefault.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x90f: // p.ListFieldWithDefault ID:9 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.ListFieldWithDefault = make([]int32, sz)
			for i := 0; i < sz; i++ {
				p.ListFieldWithDefault[i], l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xa0e: // p.SetFieldWithDefault ID:10 thrift.SET
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.SetFieldWithDefault = make([]int32, sz)
			for i := 0; i < sz; i++ {
				p.SetFieldWithDefault[i], l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xb0d: // p.MapI32I64WithDefault ID:11 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapI32I64WithDefault = make(map[int32]int64, sz)
			for i := 0; i < sz; i++ {
				var k int32
				var v int64
				k, l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapI32I64WithDefault[k] = v
			}
		case 0xc0d: // p.MapI64StringWithDefault ID:12 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapI64StringWithDefault = make(map[int64]string, sz)
			for i := 0; i < sz; i++ {
				var k int64
				var v string
				k, l, err = x.ReadI64(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapI64StringWithDefault[k] = v
			}
		case 0xd0d: // p.MapStringStringWithDefault ID:13 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringStringWithDefault = make(map[string]string, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v string
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringStringWithDefault[k] = v
			}
		case 0xe0d: // p.MapStringSimpleWithDefault ID:14 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.MapStringSimpleWithDefault = make(map[string]*Simple, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v *Simple
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v = NewSimple()
				l, err = v.FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				p.MapStringSimpleWithDefault[k] = v
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_OptionalDefaultValues[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}
