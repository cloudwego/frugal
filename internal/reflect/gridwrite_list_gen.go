/*
 * Copyright 2025 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reflect

import (
	"encoding/binary"
	"unsafe"

	"github.com/cloudwego/gopkg/gridbuf"
	"github.com/cloudwego/gopkg/unsafex"
)

// This File is generated by gridwrite_gen.sh. DO NOT EDIT.
// Template and code can be found in gridwrite_list_gen_test.go.

func init() {
	registerGridWriteListFunc(tBYTE, gridWriteList_I08)
	registerGridWriteListFunc(tI16, gridWriteList_I16)
	registerGridWriteListFunc(tI32, gridWriteList_I32)
	registerGridWriteListFunc(tI64, gridWriteList_I64)
	registerGridWriteListFunc(tDOUBLE, gridWriteList_I64)
	registerGridWriteListFunc(tENUM, gridWriteList_ENUM)
	registerGridWriteListFunc(tSTRING, gridWriteList_STRING)
	registerGridWriteListFunc(tSTRUCT, gridWriteList_Other)
	registerGridWriteListFunc(tMAP, gridWriteList_Other)
	registerGridWriteListFunc(tSET, gridWriteList_Other)
	registerGridWriteListFunc(tLIST, gridWriteList_Other)
}

func gridWriteList_I08(t *tType, b *gridbuf.WriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := gridWriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b.MallocN(1)[0] = *(*byte)(vp)
	}
	return nil
}

func gridWriteList_I16(t *tType, b *gridbuf.WriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := gridWriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		binary.BigEndian.PutUint16(b.MallocN(2), *((*uint16)(vp)))
	}
	return nil
}

func gridWriteList_I32(t *tType, b *gridbuf.WriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := gridWriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		binary.BigEndian.PutUint32(b.MallocN(4), *((*uint32)(vp)))
	}
	return nil
}

func gridWriteList_I64(t *tType, b *gridbuf.WriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := gridWriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		binary.BigEndian.PutUint64(b.MallocN(8), *((*uint64)(vp)))
	}
	return nil
}

func gridWriteList_ENUM(t *tType, b *gridbuf.WriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := gridWriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		binary.BigEndian.PutUint32(b.MallocN(4), uint32(*((*int64)(vp))))
	}
	return nil
}

func gridWriteList_STRING(t *tType, b *gridbuf.WriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := gridWriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	var s string
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		s = *((*string)(vp))
		if len(s) < nocopyWriteThreshold {
			buf := b.MallocN(len(s) + 4)
			binary.BigEndian.PutUint32(buf, uint32(len(s)))
			copy(buf[4:], s)
		} else {
			binary.BigEndian.PutUint32(b.MallocN(4), uint32(len(s)))
			b.WriteDirect(unsafex.StringToBinary(s))
		}
	}
	return nil
}

func gridWriteList_Other(t *tType, b *gridbuf.WriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := gridWriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	var err error
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		if t.IsPointer {
			err = t.GridWriteFunc(t, b, *(*unsafe.Pointer)(vp))
		} else {
			err = t.GridWriteFunc(t, b, vp)
		}
		if err != nil {
			return err
		}
	}
	return nil
}
