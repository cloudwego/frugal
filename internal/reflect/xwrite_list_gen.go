/*
 * Copyright 2025 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reflect

import (
	"encoding/binary"
	"unsafe"

	"github.com/cloudwego/gopkg/unsafex"
	"github.com/cloudwego/gopkg/xbuf"
)

// This File is generated by xwrite_gen.sh. DO NOT EDIT.
// Template and code can be found in xwrite_list_gen_test.go.

func init() {
	registerXWriteListFunc(tBYTE, xwriteList_I08)
	registerXWriteListFunc(tI16, xwriteList_I16)
	registerXWriteListFunc(tI32, xwriteList_I32)
	registerXWriteListFunc(tI64, xwriteList_I64)
	registerXWriteListFunc(tDOUBLE, xwriteList_I64)
	registerXWriteListFunc(tENUM, xwriteList_ENUM)
	registerXWriteListFunc(tSTRING, xwriteList_STRING)
	registerXWriteListFunc(tSTRUCT, xwriteList_Other)
	registerXWriteListFunc(tMAP, xwriteList_Other)
	registerXWriteListFunc(tSET, xwriteList_Other)
	registerXWriteListFunc(tLIST, xwriteList_Other)
}

func xwriteList_I08(t *tType, b *xbuf.XWriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := xwriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b.MallocN(1)[0] = *(*byte)(vp)
	}
	return nil
}

func xwriteList_I16(t *tType, b *xbuf.XWriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := xwriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		binary.BigEndian.PutUint16(b.MallocN(2), *((*uint16)(vp)))
	}
	return nil
}

func xwriteList_I32(t *tType, b *xbuf.XWriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := xwriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		binary.BigEndian.PutUint32(b.MallocN(4), *((*uint32)(vp)))
	}
	return nil
}

func xwriteList_I64(t *tType, b *xbuf.XWriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := xwriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		binary.BigEndian.PutUint64(b.MallocN(8), *((*uint64)(vp)))
	}
	return nil
}

func xwriteList_ENUM(t *tType, b *xbuf.XWriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := xwriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		binary.BigEndian.PutUint32(b.MallocN(4), uint32(*((*int64)(vp))))
	}
	return nil
}

func xwriteList_STRING(t *tType, b *xbuf.XWriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := xwriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	var s string
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		s = *((*string)(vp))
		if len(s) < nocopyWriteThreshold {
			buf := b.MallocN(len(s) + 4)
			binary.BigEndian.PutUint32(buf, uint32(len(s)))
			copy(buf[4:], s)
		} else {
			binary.BigEndian.PutUint32(b.MallocN(4), uint32(len(s)))
			b.WriteDirect(unsafex.StringToBinary(s))
		}
	}
	return nil
}

func xwriteList_Other(t *tType, b *xbuf.XWriteBuffer, p unsafe.Pointer) error {
	t = t.V
	n, vp := xwriteListHeader(t, b, p)
	if n == 0 {
		return nil
	}
	var err error
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		if t.IsPointer {
			err = t.XWriteFunc(t, b, *(*unsafe.Pointer)(vp))
		} else {
			err = t.XWriteFunc(t, b, vp)
		}
		if err != nil {
			return err
		}
	}
	return nil
}
