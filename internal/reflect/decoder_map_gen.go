/*
 * Copyright 2025 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reflect

import "unsafe"

// This File is generated by append_gen.sh. DO NOT EDIT.
// Template and code can be found in decoder_map_gen_test.go.

func init() {
	registerMapDecodeFunc(tBOOL, tBOOL, decodeMap_tBOOL_tBOOL)
	registerMapDecodeFunc(tBOOL, tI08, decodeMap_tBOOL_tI08)
	registerMapDecodeFunc(tBOOL, tI16, decodeMap_tBOOL_tI16)
	registerMapDecodeFunc(tBOOL, tI32, decodeMap_tBOOL_tI32)
	registerMapDecodeFunc(tBOOL, tI64, decodeMap_tBOOL_tI64)
	registerMapDecodeFunc(tBOOL, tDOUBLE, decodeMap_tBOOL_tI64)
	registerMapDecodeFunc(tBOOL, tENUM, decodeMap_tBOOL_tENUM)
	registerMapDecodeFunc(tBOOL, tSTRING, decodeMap_tBOOL_tSTRING)
	registerMapDecodeFunc(tBOOL, tBINARY, decodeMap_tBOOL_tBINARY)
	registerMapDecodeFunc(tI08, tBOOL, decodeMap_tI08_tBOOL)
	registerMapDecodeFunc(tI08, tI08, decodeMap_tI08_tI08)
	registerMapDecodeFunc(tI08, tI16, decodeMap_tI08_tI16)
	registerMapDecodeFunc(tI08, tI32, decodeMap_tI08_tI32)
	registerMapDecodeFunc(tI08, tI64, decodeMap_tI08_tI64)
	registerMapDecodeFunc(tI08, tDOUBLE, decodeMap_tI08_tI64)
	registerMapDecodeFunc(tI08, tENUM, decodeMap_tI08_tENUM)
	registerMapDecodeFunc(tI08, tSTRING, decodeMap_tI08_tSTRING)
	registerMapDecodeFunc(tI08, tBINARY, decodeMap_tI08_tBINARY)
	registerMapDecodeFunc(tI16, tBOOL, decodeMap_tI16_tBOOL)
	registerMapDecodeFunc(tI16, tI08, decodeMap_tI16_tI08)
	registerMapDecodeFunc(tI16, tI16, decodeMap_tI16_tI16)
	registerMapDecodeFunc(tI16, tI32, decodeMap_tI16_tI32)
	registerMapDecodeFunc(tI16, tI64, decodeMap_tI16_tI64)
	registerMapDecodeFunc(tI16, tDOUBLE, decodeMap_tI16_tI64)
	registerMapDecodeFunc(tI16, tENUM, decodeMap_tI16_tENUM)
	registerMapDecodeFunc(tI16, tSTRING, decodeMap_tI16_tSTRING)
	registerMapDecodeFunc(tI16, tBINARY, decodeMap_tI16_tBINARY)
	registerMapDecodeFunc(tI32, tBOOL, decodeMap_tI32_tBOOL)
	registerMapDecodeFunc(tI32, tI08, decodeMap_tI32_tI08)
	registerMapDecodeFunc(tI32, tI16, decodeMap_tI32_tI16)
	registerMapDecodeFunc(tI32, tI32, decodeMap_tI32_tI32)
	registerMapDecodeFunc(tI32, tI64, decodeMap_tI32_tI64)
	registerMapDecodeFunc(tI32, tDOUBLE, decodeMap_tI32_tI64)
	registerMapDecodeFunc(tI32, tENUM, decodeMap_tI32_tENUM)
	registerMapDecodeFunc(tI32, tSTRING, decodeMap_tI32_tSTRING)
	registerMapDecodeFunc(tI32, tBINARY, decodeMap_tI32_tBINARY)
	registerMapDecodeFunc(tI64, tBOOL, decodeMap_tI64_tBOOL)
	registerMapDecodeFunc(tI64, tI08, decodeMap_tI64_tI08)
	registerMapDecodeFunc(tI64, tI16, decodeMap_tI64_tI16)
	registerMapDecodeFunc(tI64, tI32, decodeMap_tI64_tI32)
	registerMapDecodeFunc(tI64, tI64, decodeMap_tI64_tI64)
	registerMapDecodeFunc(tI64, tDOUBLE, decodeMap_tI64_tI64)
	registerMapDecodeFunc(tI64, tENUM, decodeMap_tI64_tENUM)
	registerMapDecodeFunc(tI64, tSTRING, decodeMap_tI64_tSTRING)
	registerMapDecodeFunc(tI64, tBINARY, decodeMap_tI64_tBINARY)
	registerMapDecodeFunc(tDOUBLE, tBOOL, decodeMap_tI64_tBOOL)
	registerMapDecodeFunc(tDOUBLE, tI08, decodeMap_tI64_tI08)
	registerMapDecodeFunc(tDOUBLE, tI16, decodeMap_tI64_tI16)
	registerMapDecodeFunc(tDOUBLE, tI32, decodeMap_tI64_tI32)
	registerMapDecodeFunc(tDOUBLE, tI64, decodeMap_tI64_tI64)
	registerMapDecodeFunc(tDOUBLE, tDOUBLE, decodeMap_tI64_tI64)
	registerMapDecodeFunc(tDOUBLE, tENUM, decodeMap_tI64_tENUM)
	registerMapDecodeFunc(tDOUBLE, tSTRING, decodeMap_tI64_tSTRING)
	registerMapDecodeFunc(tDOUBLE, tBINARY, decodeMap_tI64_tBINARY)
	registerMapDecodeFunc(tENUM, tBOOL, decodeMap_tENUM_tBOOL)
	registerMapDecodeFunc(tENUM, tI08, decodeMap_tENUM_tI08)
	registerMapDecodeFunc(tENUM, tI16, decodeMap_tENUM_tI16)
	registerMapDecodeFunc(tENUM, tI32, decodeMap_tENUM_tI32)
	registerMapDecodeFunc(tENUM, tI64, decodeMap_tENUM_tI64)
	registerMapDecodeFunc(tENUM, tDOUBLE, decodeMap_tENUM_tI64)
	registerMapDecodeFunc(tENUM, tENUM, decodeMap_tENUM_tENUM)
	registerMapDecodeFunc(tENUM, tSTRING, decodeMap_tENUM_tSTRING)
	registerMapDecodeFunc(tENUM, tBINARY, decodeMap_tENUM_tBINARY)
	registerMapDecodeFunc(tSTRING, tBOOL, decodeMap_tSTRING_tBOOL)
	registerMapDecodeFunc(tSTRING, tI08, decodeMap_tSTRING_tI08)
	registerMapDecodeFunc(tSTRING, tI16, decodeMap_tSTRING_tI16)
	registerMapDecodeFunc(tSTRING, tI32, decodeMap_tSTRING_tI32)
	registerMapDecodeFunc(tSTRING, tI64, decodeMap_tSTRING_tI64)
	registerMapDecodeFunc(tSTRING, tDOUBLE, decodeMap_tSTRING_tI64)
	registerMapDecodeFunc(tSTRING, tENUM, decodeMap_tSTRING_tENUM)
	registerMapDecodeFunc(tSTRING, tSTRING, decodeMap_tSTRING_tSTRING)
	registerMapDecodeFunc(tSTRING, tBINARY, decodeMap_tSTRING_tBINARY)
}

func decodeMap_tBOOL_tBOOL(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[bool]bool, l)
	for j := 0; j < l; j++ {
		k := b[i] != 0
		i += 1
		v := b[i] != 0
		i += 1
		m[k] = v
	}
	*(*map[bool]bool)(p) = m
	return i, nil
}

func decodeMap_tBOOL_tI08(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[bool]byte, l)
	for j := 0; j < l; j++ {
		k := b[i] != 0
		i += 1
		v := b[i]
		i += 1
		m[k] = v
	}
	*(*map[bool]byte)(p) = m
	return i, nil
}

func decodeMap_tBOOL_tI16(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[bool]uint16, l)
	for j := 0; j < l; j++ {
		k := b[i] != 0
		i += 1
		v := decodeU16(b[i:])
		i += 2
		m[k] = v
	}
	*(*map[bool]uint16)(p) = m
	return i, nil
}

func decodeMap_tBOOL_tI32(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[bool]uint32, l)
	for j := 0; j < l; j++ {
		k := b[i] != 0
		i += 1
		v := decodeU32(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[bool]uint32)(p) = m
	return i, nil
}

func decodeMap_tBOOL_tI64(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[bool]uint64, l)
	for j := 0; j < l; j++ {
		k := b[i] != 0
		i += 1
		v := decodeU64(b[i:])
		i += 8
		m[k] = v
	}
	*(*map[bool]uint64)(p) = m
	return i, nil
}

func decodeMap_tBOOL_tENUM(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[bool]int64, l)
	for j := 0; j < l; j++ {
		k := b[i] != 0
		i += 1
		v := decodeEnum(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[bool]int64)(p) = m
	return i, nil
}

func decodeMap_tBOOL_tSTRING(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[bool]string, l)
	for j := 0; j < l; j++ {
		k := b[i] != 0
		i += 1
		var v string
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[bool]string)(p) = m
	return i, nil
}

func decodeMap_tBOOL_tBINARY(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[bool][]byte, l)
	for j := 0; j < l; j++ {
		k := b[i] != 0
		i += 1
		var v []byte
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[bool][]byte)(p) = m
	return i, nil
}

func decodeMap_tI08_tBOOL(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[byte]bool, l)
	for j := 0; j < l; j++ {
		k := b[i]
		i += 1
		v := b[i] != 0
		i += 1
		m[k] = v
	}
	*(*map[byte]bool)(p) = m
	return i, nil
}

func decodeMap_tI08_tI08(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[byte]byte, l)
	for j := 0; j < l; j++ {
		k := b[i]
		i += 1
		v := b[i]
		i += 1
		m[k] = v
	}
	*(*map[byte]byte)(p) = m
	return i, nil
}

func decodeMap_tI08_tI16(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[byte]uint16, l)
	for j := 0; j < l; j++ {
		k := b[i]
		i += 1
		v := decodeU16(b[i:])
		i += 2
		m[k] = v
	}
	*(*map[byte]uint16)(p) = m
	return i, nil
}

func decodeMap_tI08_tI32(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[byte]uint32, l)
	for j := 0; j < l; j++ {
		k := b[i]
		i += 1
		v := decodeU32(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[byte]uint32)(p) = m
	return i, nil
}

func decodeMap_tI08_tI64(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[byte]uint64, l)
	for j := 0; j < l; j++ {
		k := b[i]
		i += 1
		v := decodeU64(b[i:])
		i += 8
		m[k] = v
	}
	*(*map[byte]uint64)(p) = m
	return i, nil
}

func decodeMap_tI08_tENUM(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[byte]int64, l)
	for j := 0; j < l; j++ {
		k := b[i]
		i += 1
		v := decodeEnum(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[byte]int64)(p) = m
	return i, nil
}

func decodeMap_tI08_tSTRING(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[byte]string, l)
	for j := 0; j < l; j++ {
		k := b[i]
		i += 1
		var v string
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[byte]string)(p) = m
	return i, nil
}

func decodeMap_tI08_tBINARY(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[byte][]byte, l)
	for j := 0; j < l; j++ {
		k := b[i]
		i += 1
		var v []byte
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[byte][]byte)(p) = m
	return i, nil
}

func decodeMap_tI16_tBOOL(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint16]bool, l)
	for j := 0; j < l; j++ {
		k := decodeU16(b[i:])
		i += 2
		v := b[i] != 0
		i += 1
		m[k] = v
	}
	*(*map[uint16]bool)(p) = m
	return i, nil
}

func decodeMap_tI16_tI08(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint16]byte, l)
	for j := 0; j < l; j++ {
		k := decodeU16(b[i:])
		i += 2
		v := b[i]
		i += 1
		m[k] = v
	}
	*(*map[uint16]byte)(p) = m
	return i, nil
}

func decodeMap_tI16_tI16(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint16]uint16, l)
	for j := 0; j < l; j++ {
		k := decodeU16(b[i:])
		i += 2
		v := decodeU16(b[i:])
		i += 2
		m[k] = v
	}
	*(*map[uint16]uint16)(p) = m
	return i, nil
}

func decodeMap_tI16_tI32(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint16]uint32, l)
	for j := 0; j < l; j++ {
		k := decodeU16(b[i:])
		i += 2
		v := decodeU32(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[uint16]uint32)(p) = m
	return i, nil
}

func decodeMap_tI16_tI64(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint16]uint64, l)
	for j := 0; j < l; j++ {
		k := decodeU16(b[i:])
		i += 2
		v := decodeU64(b[i:])
		i += 8
		m[k] = v
	}
	*(*map[uint16]uint64)(p) = m
	return i, nil
}

func decodeMap_tI16_tENUM(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint16]int64, l)
	for j := 0; j < l; j++ {
		k := decodeU16(b[i:])
		i += 2
		v := decodeEnum(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[uint16]int64)(p) = m
	return i, nil
}

func decodeMap_tI16_tSTRING(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[uint16]string, l)
	for j := 0; j < l; j++ {
		k := decodeU16(b[i:])
		i += 2
		var v string
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[uint16]string)(p) = m
	return i, nil
}

func decodeMap_tI16_tBINARY(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[uint16][]byte, l)
	for j := 0; j < l; j++ {
		k := decodeU16(b[i:])
		i += 2
		var v []byte
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[uint16][]byte)(p) = m
	return i, nil
}

func decodeMap_tI32_tBOOL(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint32]bool, l)
	for j := 0; j < l; j++ {
		k := decodeU32(b[i:])
		i += 4
		v := b[i] != 0
		i += 1
		m[k] = v
	}
	*(*map[uint32]bool)(p) = m
	return i, nil
}

func decodeMap_tI32_tI08(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint32]byte, l)
	for j := 0; j < l; j++ {
		k := decodeU32(b[i:])
		i += 4
		v := b[i]
		i += 1
		m[k] = v
	}
	*(*map[uint32]byte)(p) = m
	return i, nil
}

func decodeMap_tI32_tI16(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint32]uint16, l)
	for j := 0; j < l; j++ {
		k := decodeU32(b[i:])
		i += 4
		v := decodeU16(b[i:])
		i += 2
		m[k] = v
	}
	*(*map[uint32]uint16)(p) = m
	return i, nil
}

func decodeMap_tI32_tI32(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint32]uint32, l)
	for j := 0; j < l; j++ {
		k := decodeU32(b[i:])
		i += 4
		v := decodeU32(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[uint32]uint32)(p) = m
	return i, nil
}

func decodeMap_tI32_tI64(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint32]uint64, l)
	for j := 0; j < l; j++ {
		k := decodeU32(b[i:])
		i += 4
		v := decodeU64(b[i:])
		i += 8
		m[k] = v
	}
	*(*map[uint32]uint64)(p) = m
	return i, nil
}

func decodeMap_tI32_tENUM(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint32]int64, l)
	for j := 0; j < l; j++ {
		k := decodeU32(b[i:])
		i += 4
		v := decodeEnum(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[uint32]int64)(p) = m
	return i, nil
}

func decodeMap_tI32_tSTRING(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[uint32]string, l)
	for j := 0; j < l; j++ {
		k := decodeU32(b[i:])
		i += 4
		var v string
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[uint32]string)(p) = m
	return i, nil
}

func decodeMap_tI32_tBINARY(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[uint32][]byte, l)
	for j := 0; j < l; j++ {
		k := decodeU32(b[i:])
		i += 4
		var v []byte
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[uint32][]byte)(p) = m
	return i, nil
}

func decodeMap_tI64_tBOOL(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint64]bool, l)
	for j := 0; j < l; j++ {
		k := decodeU64(b[i:])
		i += 8
		v := b[i] != 0
		i += 1
		m[k] = v
	}
	*(*map[uint64]bool)(p) = m
	return i, nil
}

func decodeMap_tI64_tI08(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint64]byte, l)
	for j := 0; j < l; j++ {
		k := decodeU64(b[i:])
		i += 8
		v := b[i]
		i += 1
		m[k] = v
	}
	*(*map[uint64]byte)(p) = m
	return i, nil
}

func decodeMap_tI64_tI16(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint64]uint16, l)
	for j := 0; j < l; j++ {
		k := decodeU64(b[i:])
		i += 8
		v := decodeU16(b[i:])
		i += 2
		m[k] = v
	}
	*(*map[uint64]uint16)(p) = m
	return i, nil
}

func decodeMap_tI64_tI32(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint64]uint32, l)
	for j := 0; j < l; j++ {
		k := decodeU64(b[i:])
		i += 8
		v := decodeU32(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[uint64]uint32)(p) = m
	return i, nil
}

func decodeMap_tI64_tI64(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint64]uint64, l)
	for j := 0; j < l; j++ {
		k := decodeU64(b[i:])
		i += 8
		v := decodeU64(b[i:])
		i += 8
		m[k] = v
	}
	*(*map[uint64]uint64)(p) = m
	return i, nil
}

func decodeMap_tI64_tENUM(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[uint64]int64, l)
	for j := 0; j < l; j++ {
		k := decodeU64(b[i:])
		i += 8
		v := decodeEnum(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[uint64]int64)(p) = m
	return i, nil
}

func decodeMap_tI64_tSTRING(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[uint64]string, l)
	for j := 0; j < l; j++ {
		k := decodeU64(b[i:])
		i += 8
		var v string
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[uint64]string)(p) = m
	return i, nil
}

func decodeMap_tI64_tBINARY(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[uint64][]byte, l)
	for j := 0; j < l; j++ {
		k := decodeU64(b[i:])
		i += 8
		var v []byte
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[uint64][]byte)(p) = m
	return i, nil
}

func decodeMap_tENUM_tBOOL(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[int64]bool, l)
	for j := 0; j < l; j++ {
		k := decodeEnum(b[i:])
		i += 4
		v := b[i] != 0
		i += 1
		m[k] = v
	}
	*(*map[int64]bool)(p) = m
	return i, nil
}

func decodeMap_tENUM_tI08(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[int64]byte, l)
	for j := 0; j < l; j++ {
		k := decodeEnum(b[i:])
		i += 4
		v := b[i]
		i += 1
		m[k] = v
	}
	*(*map[int64]byte)(p) = m
	return i, nil
}

func decodeMap_tENUM_tI16(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[int64]uint16, l)
	for j := 0; j < l; j++ {
		k := decodeEnum(b[i:])
		i += 4
		v := decodeU16(b[i:])
		i += 2
		m[k] = v
	}
	*(*map[int64]uint16)(p) = m
	return i, nil
}

func decodeMap_tENUM_tI32(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[int64]uint32, l)
	for j := 0; j < l; j++ {
		k := decodeEnum(b[i:])
		i += 4
		v := decodeU32(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[int64]uint32)(p) = m
	return i, nil
}

func decodeMap_tENUM_tI64(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[int64]uint64, l)
	for j := 0; j < l; j++ {
		k := decodeEnum(b[i:])
		i += 4
		v := decodeU64(b[i:])
		i += 8
		m[k] = v
	}
	*(*map[int64]uint64)(p) = m
	return i, nil
}

func decodeMap_tENUM_tENUM(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	i, m := 6, make(map[int64]int64, l)
	for j := 0; j < l; j++ {
		k := decodeEnum(b[i:])
		i += 4
		v := decodeEnum(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[int64]int64)(p) = m
	return i, nil
}

func decodeMap_tENUM_tSTRING(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[int64]string, l)
	for j := 0; j < l; j++ {
		k := decodeEnum(b[i:])
		i += 4
		var v string
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[int64]string)(p) = m
	return i, nil
}

func decodeMap_tENUM_tBINARY(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[int64][]byte, l)
	for j := 0; j < l; j++ {
		k := decodeEnum(b[i:])
		i += 4
		var v []byte
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[int64][]byte)(p) = m
	return i, nil
}

func decodeMap_tSTRING_tBOOL(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[string]bool, l)
	for j := 0; j < l; j++ {
		var k string
		n, err = _decoderString(d, t.K, b[i:], unsafe.Pointer(&k), false)
		if err != nil {
			return i, err
		}
		i += n
		v := b[i] != 0
		i += 1
		m[k] = v
	}
	*(*map[string]bool)(p) = m
	return i, nil
}

func decodeMap_tSTRING_tI08(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[string]byte, l)
	for j := 0; j < l; j++ {
		var k string
		n, err = _decoderString(d, t.K, b[i:], unsafe.Pointer(&k), false)
		if err != nil {
			return i, err
		}
		i += n
		v := b[i]
		i += 1
		m[k] = v
	}
	*(*map[string]byte)(p) = m
	return i, nil
}

func decodeMap_tSTRING_tI16(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[string]uint16, l)
	for j := 0; j < l; j++ {
		var k string
		n, err = _decoderString(d, t.K, b[i:], unsafe.Pointer(&k), false)
		if err != nil {
			return i, err
		}
		i += n
		v := decodeU16(b[i:])
		i += 2
		m[k] = v
	}
	*(*map[string]uint16)(p) = m
	return i, nil
}

func decodeMap_tSTRING_tI32(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[string]uint32, l)
	for j := 0; j < l; j++ {
		var k string
		n, err = _decoderString(d, t.K, b[i:], unsafe.Pointer(&k), false)
		if err != nil {
			return i, err
		}
		i += n
		v := decodeU32(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[string]uint32)(p) = m
	return i, nil
}

func decodeMap_tSTRING_tI64(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[string]uint64, l)
	for j := 0; j < l; j++ {
		var k string
		n, err = _decoderString(d, t.K, b[i:], unsafe.Pointer(&k), false)
		if err != nil {
			return i, err
		}
		i += n
		v := decodeU64(b[i:])
		i += 8
		m[k] = v
	}
	*(*map[string]uint64)(p) = m
	return i, nil
}

func decodeMap_tSTRING_tENUM(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[string]int64, l)
	for j := 0; j < l; j++ {
		var k string
		n, err = _decoderString(d, t.K, b[i:], unsafe.Pointer(&k), false)
		if err != nil {
			return i, err
		}
		i += n
		v := decodeEnum(b[i:])
		i += 4
		m[k] = v
	}
	*(*map[string]int64)(p) = m
	return i, nil
}

func decodeMap_tSTRING_tSTRING(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[string]string, l)
	for j := 0; j < l; j++ {
		var k string
		n, err = _decoderString(d, t.K, b[i:], unsafe.Pointer(&k), false)
		if err != nil {
			return i, err
		}
		i += n
		var v string
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[string]string)(p) = m
	return i, nil
}

func decodeMap_tSTRING_tBINARY(d *tDecoder, t *tType, b []byte, p unsafe.Pointer, maxdepth int) (int, error) {
	l, err := decodeMapHeader(t, b)
	if err != nil {
		return 0, err
	}
	var n int
	i, m := 6, make(map[string][]byte, l)
	for j := 0; j < l; j++ {
		var k string
		n, err = _decoderString(d, t.K, b[i:], unsafe.Pointer(&k), false)
		if err != nil {
			return i, err
		}
		i += n
		var v []byte
		n, err = _decoderString(d, t.V, b[i:], unsafe.Pointer(&v), false)
		if err != nil {
			return i, err
		}
		i += n
		m[k] = v
	}
	*(*map[string][]byte)(p) = m
	return i, nil
}
