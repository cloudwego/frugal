/*
 * Copyright 2024 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reflect

import "unsafe"

// This File is generated by append_gen.sh. DO NOT EDIT.
// Template and code can be found in append_list_gen_test.go.

func init() {
	registerListAppendFunc(tBYTE, appendList_I08)
	registerListAppendFunc(tI16, appendList_I16)
	registerListAppendFunc(tI32, appendList_I32)
	registerListAppendFunc(tI64, appendList_I64)
	registerListAppendFunc(tDOUBLE, appendList_I64)
	registerListAppendFunc(tENUM, appendList_ENUM)
	registerListAppendFunc(tSTRING, appendList_STRING)
	registerListAppendFunc(tSTRUCT, appendList_Other)
	registerListAppendFunc(tMAP, appendList_Other)
	registerListAppendFunc(tSET, appendList_Other)
	registerListAppendFunc(tLIST, appendList_Other)
}

func appendList_I08(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = append(b, *((*byte)(vp)))
	}
	return b, nil
}

func appendList_I16(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = appendUint16(b, *((*uint16)(vp)))
	}
	return b, nil
}

func appendList_I32(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = appendUint32(b, *((*uint32)(vp)))
	}
	return b, nil
}

func appendList_I64(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = appendUint64(b, *((*uint64)(vp)))
	}
	return b, nil
}

func appendList_ENUM(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = appendUint32(b, uint32(*((*int64)(vp))))
	}
	return b, nil
}

func appendList_STRING(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	var s string
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		s = *((*string)(vp))
		b = appendUint32(b, uint32(len(s)))
		b = append(b, s...)
	}
	return b, nil
}

func appendList_Other(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	var err error
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		if t.IsPointer {
			b, err = t.AppendFunc(t, b, *(*unsafe.Pointer)(vp))
		} else {
			b, err = t.AppendFunc(t, b, vp)
		}
		if err != nil {
			return b, err
		}
	}
	return b, nil
}
