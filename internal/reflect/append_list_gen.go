/*
 * Copyright 2024 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reflect

import "unsafe"

// This File is generated by append_gen.sh. DO NOT EDIT.
// Template and code can be found in append_list_gen_test.go.

func init() {
	registerListAppendFunc(tI08, appendList_tI08)
	registerListAppendFunc(tI16, appendList_tI16)
	registerListAppendFunc(tI32, appendList_tI32)
	registerListAppendFunc(tI64, appendList_tI64)
	registerListAppendFunc(tDOUBLE, appendList_tI64)
	registerListAppendFunc(tENUM, appendList_tENUM)
	registerListAppendFunc(tSTRING, appendList_tSTRING)
	registerListAppendFunc(tSTRUCT, appendList_tOTHER)
	registerListAppendFunc(tMAP, appendList_tOTHER)
	registerListAppendFunc(tSET, appendList_tOTHER)
	registerListAppendFunc(tLIST, appendList_tOTHER)
}

func appendList_tI08(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = append(b, *(*byte)(vp))
	}
	return b, nil
}

func appendList_tI16(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = appendUint16(b, *(*uint16)(vp))
	}
	return b, nil
}

func appendList_tI32(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = appendUint32(b, *(*uint32)(vp))
	}
	return b, nil
}

func appendList_tI64(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = appendUint64(b, *(*uint64)(vp))
	}
	return b, nil
}

func appendList_tENUM(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		b = appendUint32(b, uint32(*(*uint64)(vp)))
	}
	return b, nil
}

func appendList_tSTRING(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		s := *(*string)(vp)
		b = appendUint32(b, uint32(len(s)))
		b = append(b, s...)
	}
	return b, nil
}

func appendList_tOTHER(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	t = t.V
	b, n, vp := appendListHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for i := uint32(0); i < n; i++ {
		if i != 0 {
			vp = unsafe.Add(vp, t.Size)
		}
		var err error
		if t.IsPointer {
			b, err = t.AppendFunc(t, b, *(*unsafe.Pointer)(vp))
		} else {
			b, err = t.AppendFunc(t, b, vp)
		}
		if err != nil {
			return b, err
		}
	}
	return b, nil
}
