/*
 * Copyright 2024 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reflect

import "unsafe"

// This File is generated by append_gen.sh. DO NOT EDIT.
// Template and code can be found in append_map_gen_test.go.

func init() {
	registerMapAppendFunc(tI08, tI08, appendMap_tI08_tI08)
	registerMapAppendFunc(tI08, tI16, appendMap_tI08_tI16)
	registerMapAppendFunc(tI08, tI32, appendMap_tI08_tI32)
	registerMapAppendFunc(tI08, tI64, appendMap_tI08_tI64)
	registerMapAppendFunc(tI08, tDOUBLE, appendMap_tI08_tI64)
	registerMapAppendFunc(tI08, tENUM, appendMap_tI08_tENUM)
	registerMapAppendFunc(tI08, tSTRING, appendMap_tI08_tSTRING)
	registerMapAppendFunc(tI08, tSTRUCT, appendMap_tI08_tOTHER)
	registerMapAppendFunc(tI08, tMAP, appendMap_tI08_tOTHER)
	registerMapAppendFunc(tI08, tSET, appendMap_tI08_tOTHER)
	registerMapAppendFunc(tI08, tLIST, appendMap_tI08_tOTHER)
	registerMapAppendFunc(tI16, tI08, appendMap_tI16_tI08)
	registerMapAppendFunc(tI16, tI16, appendMap_tI16_tI16)
	registerMapAppendFunc(tI16, tI32, appendMap_tI16_tI32)
	registerMapAppendFunc(tI16, tI64, appendMap_tI16_tI64)
	registerMapAppendFunc(tI16, tDOUBLE, appendMap_tI16_tI64)
	registerMapAppendFunc(tI16, tENUM, appendMap_tI16_tENUM)
	registerMapAppendFunc(tI16, tSTRING, appendMap_tI16_tSTRING)
	registerMapAppendFunc(tI16, tSTRUCT, appendMap_tI16_tOTHER)
	registerMapAppendFunc(tI16, tMAP, appendMap_tI16_tOTHER)
	registerMapAppendFunc(tI16, tSET, appendMap_tI16_tOTHER)
	registerMapAppendFunc(tI16, tLIST, appendMap_tI16_tOTHER)
	registerMapAppendFunc(tI32, tI08, appendMap_tI32_tI08)
	registerMapAppendFunc(tI32, tI16, appendMap_tI32_tI16)
	registerMapAppendFunc(tI32, tI32, appendMap_tI32_tI32)
	registerMapAppendFunc(tI32, tI64, appendMap_tI32_tI64)
	registerMapAppendFunc(tI32, tDOUBLE, appendMap_tI32_tI64)
	registerMapAppendFunc(tI32, tENUM, appendMap_tI32_tENUM)
	registerMapAppendFunc(tI32, tSTRING, appendMap_tI32_tSTRING)
	registerMapAppendFunc(tI32, tSTRUCT, appendMap_tI32_tOTHER)
	registerMapAppendFunc(tI32, tMAP, appendMap_tI32_tOTHER)
	registerMapAppendFunc(tI32, tSET, appendMap_tI32_tOTHER)
	registerMapAppendFunc(tI32, tLIST, appendMap_tI32_tOTHER)
	registerMapAppendFunc(tI64, tI08, appendMap_tI64_tI08)
	registerMapAppendFunc(tI64, tI16, appendMap_tI64_tI16)
	registerMapAppendFunc(tI64, tI32, appendMap_tI64_tI32)
	registerMapAppendFunc(tI64, tI64, appendMap_tI64_tI64)
	registerMapAppendFunc(tI64, tDOUBLE, appendMap_tI64_tI64)
	registerMapAppendFunc(tI64, tENUM, appendMap_tI64_tENUM)
	registerMapAppendFunc(tI64, tSTRING, appendMap_tI64_tSTRING)
	registerMapAppendFunc(tI64, tSTRUCT, appendMap_tI64_tOTHER)
	registerMapAppendFunc(tI64, tMAP, appendMap_tI64_tOTHER)
	registerMapAppendFunc(tI64, tSET, appendMap_tI64_tOTHER)
	registerMapAppendFunc(tI64, tLIST, appendMap_tI64_tOTHER)
	registerMapAppendFunc(tDOUBLE, tI08, appendMap_tI64_tI08)
	registerMapAppendFunc(tDOUBLE, tI16, appendMap_tI64_tI16)
	registerMapAppendFunc(tDOUBLE, tI32, appendMap_tI64_tI32)
	registerMapAppendFunc(tDOUBLE, tI64, appendMap_tI64_tI64)
	registerMapAppendFunc(tDOUBLE, tDOUBLE, appendMap_tI64_tI64)
	registerMapAppendFunc(tDOUBLE, tENUM, appendMap_tI64_tENUM)
	registerMapAppendFunc(tDOUBLE, tSTRING, appendMap_tI64_tSTRING)
	registerMapAppendFunc(tDOUBLE, tSTRUCT, appendMap_tI64_tOTHER)
	registerMapAppendFunc(tDOUBLE, tMAP, appendMap_tI64_tOTHER)
	registerMapAppendFunc(tDOUBLE, tSET, appendMap_tI64_tOTHER)
	registerMapAppendFunc(tDOUBLE, tLIST, appendMap_tI64_tOTHER)
	registerMapAppendFunc(tENUM, tI08, appendMap_tENUM_tI08)
	registerMapAppendFunc(tENUM, tI16, appendMap_tENUM_tI16)
	registerMapAppendFunc(tENUM, tI32, appendMap_tENUM_tI32)
	registerMapAppendFunc(tENUM, tI64, appendMap_tENUM_tI64)
	registerMapAppendFunc(tENUM, tDOUBLE, appendMap_tENUM_tI64)
	registerMapAppendFunc(tENUM, tENUM, appendMap_tENUM_tENUM)
	registerMapAppendFunc(tENUM, tSTRING, appendMap_tENUM_tSTRING)
	registerMapAppendFunc(tENUM, tSTRUCT, appendMap_tENUM_tOTHER)
	registerMapAppendFunc(tENUM, tMAP, appendMap_tENUM_tOTHER)
	registerMapAppendFunc(tENUM, tSET, appendMap_tENUM_tOTHER)
	registerMapAppendFunc(tENUM, tLIST, appendMap_tENUM_tOTHER)
	registerMapAppendFunc(tSTRING, tI08, appendMap_tSTRING_tI08)
	registerMapAppendFunc(tSTRING, tI16, appendMap_tSTRING_tI16)
	registerMapAppendFunc(tSTRING, tI32, appendMap_tSTRING_tI32)
	registerMapAppendFunc(tSTRING, tI64, appendMap_tSTRING_tI64)
	registerMapAppendFunc(tSTRING, tDOUBLE, appendMap_tSTRING_tI64)
	registerMapAppendFunc(tSTRING, tENUM, appendMap_tSTRING_tENUM)
	registerMapAppendFunc(tSTRING, tSTRING, appendMap_tSTRING_tSTRING)
	registerMapAppendFunc(tSTRING, tSTRUCT, appendMap_tSTRING_tOTHER)
	registerMapAppendFunc(tSTRING, tMAP, appendMap_tSTRING_tOTHER)
	registerMapAppendFunc(tSTRING, tSET, appendMap_tSTRING_tOTHER)
	registerMapAppendFunc(tSTRING, tLIST, appendMap_tSTRING_tOTHER)
}

func appendMap_tI08_tI08(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[byte]byte)(p) {
		n--
		b = append(b, k)
		b = append(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI08_tI16(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[byte]uint16)(p) {
		n--
		b = append(b, k)
		b = appendUint16(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI08_tI32(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[byte]uint32)(p) {
		n--
		b = append(b, k)
		b = appendUint32(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI08_tI64(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[byte]uint64)(p) {
		n--
		b = append(b, k)
		b = appendUint64(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI08_tENUM(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[byte]int64)(p) {
		n--
		b = append(b, k)
		b = appendUint32(b, uint32(v))
	}
	return b, checkMapN(n)
}

func appendMap_tI08_tSTRING(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[byte]string)(p) {
		n--
		b = append(b, k)
		b = appendUint32(b, uint32(len(v)))
		b = append(b, v...)
	}
	return b, checkMapN(n)
}

func appendMap_tI08_tOTHER(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	var err error
	it := newMapIter(rvWithPtr(t.RV, p))
	for kp, vp := it.Next(); kp != nil; kp, vp = it.Next() {
		n--
		b = append(b, *(*byte)(kp))
		if t.V.IsPointer {
			b, err = t.V.AppendFunc(t.V, b, *(*unsafe.Pointer)(vp))
		} else {
			b, err = t.V.AppendFunc(t.V, b, vp)
		}
		if err != nil {
			return b, err
		}
	}
	return b, checkMapN(n)
}

func appendMap_tI16_tI08(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint16]byte)(p) {
		n--
		b = appendUint16(b, k)
		b = append(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI16_tI16(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint16]uint16)(p) {
		n--
		b = appendUint16(b, k)
		b = appendUint16(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI16_tI32(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint16]uint32)(p) {
		n--
		b = appendUint16(b, k)
		b = appendUint32(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI16_tI64(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint16]uint64)(p) {
		n--
		b = appendUint16(b, k)
		b = appendUint64(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI16_tENUM(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint16]int64)(p) {
		n--
		b = appendUint16(b, k)
		b = appendUint32(b, uint32(v))
	}
	return b, checkMapN(n)
}

func appendMap_tI16_tSTRING(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint16]string)(p) {
		n--
		b = appendUint16(b, k)
		b = appendUint32(b, uint32(len(v)))
		b = append(b, v...)
	}
	return b, checkMapN(n)
}

func appendMap_tI16_tOTHER(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	var err error
	it := newMapIter(rvWithPtr(t.RV, p))
	for kp, vp := it.Next(); kp != nil; kp, vp = it.Next() {
		n--
		b = appendUint16(b, *(*uint16)(kp))
		if t.V.IsPointer {
			b, err = t.V.AppendFunc(t.V, b, *(*unsafe.Pointer)(vp))
		} else {
			b, err = t.V.AppendFunc(t.V, b, vp)
		}
		if err != nil {
			return b, err
		}
	}
	return b, checkMapN(n)
}

func appendMap_tI32_tI08(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint32]byte)(p) {
		n--
		b = appendUint32(b, k)
		b = append(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI32_tI16(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint32]uint16)(p) {
		n--
		b = appendUint32(b, k)
		b = appendUint16(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI32_tI32(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint32]uint32)(p) {
		n--
		b = appendUint32(b, k)
		b = appendUint32(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI32_tI64(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint32]uint64)(p) {
		n--
		b = appendUint32(b, k)
		b = appendUint64(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI32_tENUM(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint32]int64)(p) {
		n--
		b = appendUint32(b, k)
		b = appendUint32(b, uint32(v))
	}
	return b, checkMapN(n)
}

func appendMap_tI32_tSTRING(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint32]string)(p) {
		n--
		b = appendUint32(b, k)
		b = appendUint32(b, uint32(len(v)))
		b = append(b, v...)
	}
	return b, checkMapN(n)
}

func appendMap_tI32_tOTHER(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	var err error
	it := newMapIter(rvWithPtr(t.RV, p))
	for kp, vp := it.Next(); kp != nil; kp, vp = it.Next() {
		n--
		b = appendUint32(b, *(*uint32)(kp))
		if t.V.IsPointer {
			b, err = t.V.AppendFunc(t.V, b, *(*unsafe.Pointer)(vp))
		} else {
			b, err = t.V.AppendFunc(t.V, b, vp)
		}
		if err != nil {
			return b, err
		}
	}
	return b, checkMapN(n)
}

func appendMap_tI64_tI08(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint64]byte)(p) {
		n--
		b = appendUint64(b, k)
		b = append(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI64_tI16(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint64]uint16)(p) {
		n--
		b = appendUint64(b, k)
		b = appendUint16(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI64_tI32(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint64]uint32)(p) {
		n--
		b = appendUint64(b, k)
		b = appendUint32(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI64_tI64(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint64]uint64)(p) {
		n--
		b = appendUint64(b, k)
		b = appendUint64(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tI64_tENUM(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint64]int64)(p) {
		n--
		b = appendUint64(b, k)
		b = appendUint32(b, uint32(v))
	}
	return b, checkMapN(n)
}

func appendMap_tI64_tSTRING(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[uint64]string)(p) {
		n--
		b = appendUint64(b, k)
		b = appendUint32(b, uint32(len(v)))
		b = append(b, v...)
	}
	return b, checkMapN(n)
}

func appendMap_tI64_tOTHER(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	var err error
	it := newMapIter(rvWithPtr(t.RV, p))
	for kp, vp := it.Next(); kp != nil; kp, vp = it.Next() {
		n--
		b = appendUint64(b, *(*uint64)(kp))
		if t.V.IsPointer {
			b, err = t.V.AppendFunc(t.V, b, *(*unsafe.Pointer)(vp))
		} else {
			b, err = t.V.AppendFunc(t.V, b, vp)
		}
		if err != nil {
			return b, err
		}
	}
	return b, checkMapN(n)
}

func appendMap_tENUM_tI08(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[int64]byte)(p) {
		n--
		b = appendUint32(b, uint32(k))
		b = append(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tENUM_tI16(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[int64]uint16)(p) {
		n--
		b = appendUint32(b, uint32(k))
		b = appendUint16(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tENUM_tI32(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[int64]uint32)(p) {
		n--
		b = appendUint32(b, uint32(k))
		b = appendUint32(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tENUM_tI64(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[int64]uint64)(p) {
		n--
		b = appendUint32(b, uint32(k))
		b = appendUint64(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tENUM_tENUM(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[int64]int64)(p) {
		n--
		b = appendUint32(b, uint32(k))
		b = appendUint32(b, uint32(v))
	}
	return b, checkMapN(n)
}

func appendMap_tENUM_tSTRING(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[int64]string)(p) {
		n--
		b = appendUint32(b, uint32(k))
		b = appendUint32(b, uint32(len(v)))
		b = append(b, v...)
	}
	return b, checkMapN(n)
}

func appendMap_tENUM_tOTHER(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	var err error
	it := newMapIter(rvWithPtr(t.RV, p))
	for kp, vp := it.Next(); kp != nil; kp, vp = it.Next() {
		n--
		b = appendUint32(b, uint32(*(*int64)(kp)))
		if t.V.IsPointer {
			b, err = t.V.AppendFunc(t.V, b, *(*unsafe.Pointer)(vp))
		} else {
			b, err = t.V.AppendFunc(t.V, b, vp)
		}
		if err != nil {
			return b, err
		}
	}
	return b, checkMapN(n)
}

func appendMap_tSTRING_tI08(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[string]byte)(p) {
		n--
		b = appendUint32(b, uint32(len(k)))
		b = append(b, k...)
		b = append(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tSTRING_tI16(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[string]uint16)(p) {
		n--
		b = appendUint32(b, uint32(len(k)))
		b = append(b, k...)
		b = appendUint16(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tSTRING_tI32(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[string]uint32)(p) {
		n--
		b = appendUint32(b, uint32(len(k)))
		b = append(b, k...)
		b = appendUint32(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tSTRING_tI64(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[string]uint64)(p) {
		n--
		b = appendUint32(b, uint32(len(k)))
		b = append(b, k...)
		b = appendUint64(b, v)
	}
	return b, checkMapN(n)
}

func appendMap_tSTRING_tENUM(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[string]int64)(p) {
		n--
		b = appendUint32(b, uint32(len(k)))
		b = append(b, k...)
		b = appendUint32(b, uint32(v))
	}
	return b, checkMapN(n)
}

func appendMap_tSTRING_tSTRING(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	for k, v := range *(*map[string]string)(p) {
		n--
		b = appendUint32(b, uint32(len(k)))
		b = append(b, k...)
		b = appendUint32(b, uint32(len(v)))
		b = append(b, v...)
	}
	return b, checkMapN(n)
}

func appendMap_tSTRING_tOTHER(t *tType, b []byte, p unsafe.Pointer) ([]byte, error) {
	b, n := appendMapHeader(t, b, p)
	if n == 0 {
		return b, nil
	}
	var err error
	var s string
	it := newMapIter(rvWithPtr(t.RV, p))
	for kp, vp := it.Next(); kp != nil; kp, vp = it.Next() {
		n--
		s = *(*string)(kp)
		b = appendUint32(b, uint32(len(s)))
		b = append(b, s...)
		if t.V.IsPointer {
			b, err = t.V.AppendFunc(t.V, b, *(*unsafe.Pointer)(vp))
		} else {
			b, err = t.V.AppendFunc(t.V, b, vp)
		}
		if err != nil {
			return b, err
		}
	}
	return b, checkMapN(n)
}
