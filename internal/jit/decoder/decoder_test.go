/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package decoder

import (
	"testing"
	"unsafe"

	"github.com/cloudwego/frugal/internal/jit/rt"
	"github.com/davecgh/go-spew/spew"
	"github.com/stretchr/testify/require"
)

func TestDecoder_Decode(t *testing.T) {
	var v TranslatorTestStruct
	rs := new(RuntimeState)
	buf := []byte{
		0x02, 0x00, 0x00, 0x01, 0x03, 0x00, 0x01, 0x12, 0x04, 0x00, 0x02, 0x40, 0x28, 0xae, 0x14, 0x7a,
		0xe1, 0x47, 0xae, 0x06, 0x00, 0x03, 0x34, 0x56, 0x08, 0x00, 0x04, 0x12, 0x34, 0x56, 0x78, 0x0a,
		0x00, 0x05, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0x0b, 0x00, 0x06, 0x00, 0x00, 0x00,
		0x0c, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x0b, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x0e, 0x74, 0x65, 0x73, 0x74, 0x62, 0x79, 0x74, 0x65, 0x62, 0x75, 0x66, 0x66,
		0x65, 0x72, 0x0f, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x05, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
		0x77, 0x88, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x0d, 0x00,
		0x09, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x61, 0x73, 0x64, 0x66, 0x00,
		0x00, 0x00, 0x04, 0x71, 0x77, 0x65, 0x72, 0x00, 0x00, 0x00, 0x04, 0x7a, 0x78, 0x63, 0x76, 0x00,
		0x00, 0x00, 0x04, 0x68, 0x6a, 0x6b, 0x6c, 0x0d, 0x00, 0x41, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x03, 0x66, 0x6f, 0x6f, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0xff, 0x04,
		0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x03, 0x00, 0x00, 0x08,
		0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0b, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x0f,
		0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x09, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x00,
		0x0d, 0x00, 0x41, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	sl := (*rt.GoSlice)(unsafe.Pointer(&buf))
	pos, err := decode(rt.UnpackEface(v).Type, sl.Ptr, sl.Len, 0, unsafe.Pointer(&v), rs, 0)
	require.NoError(t, err)
	require.Equal(t, len(buf), pos)
	require.Equal(t, TranslatorTestStruct{
		A: true,
		B: 0x12,
		C: 12.34,
		D: 0x3456,
		E: 0x12345678,
		F: 0x66778899aabbccdd,
		G: "hello, world",
		H: []byte("testbytebuffer"),
		I: []int32{0x11223344, 0x55667788, 3, 4, 5},
		J: map[string]string{"asdf": "qwer", "zxcv": "hjkl"},
		K: map[string]*TranslatorTestStruct{
			"foo": {
				B: -1,
				H: []uint8{},
				I: []int32{},
				J: map[string]string{},
				K: map[string]*TranslatorTestStruct{},
			},
		},
	}, v)
	spew.Dump(v)
}

type TestSimple struct {
	A bool `frugal:"0,default,bool"`
}

func TestDecoder_Simple(t *testing.T) {
	var v TestSimple
	rs := new(RuntimeState)
	buf := []byte{
		0x02, 0x00, 0x00, 0x01, 0x03, 0x00, 0x01, 0x12, 0x04, 0x00, 0x02, 0x40, 0x28, 0xae, 0x14, 0x7a,
		0xe1, 0x47, 0xae, 0x06, 0x00, 0x03, 0x34, 0x56, 0x08, 0x00, 0x04, 0x12, 0x34, 0x56, 0x78, 0x0a,
		0x00, 0x05, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0x0b, 0x00, 0x06, 0x00, 0x00, 0x00,
		0x0c, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x0b, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x0e, 0x74, 0x65, 0x73, 0x74, 0x62, 0x79, 0x74, 0x65, 0x62, 0x75, 0x66, 0x66,
		0x65, 0x72, 0x0f, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x05, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
		0x77, 0x88, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x0d, 0x00,
		0x09, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x61, 0x73, 0x64, 0x66, 0x00,
		0x00, 0x00, 0x04, 0x71, 0x77, 0x65, 0x72, 0x00, 0x00, 0x00, 0x04, 0x7a, 0x78, 0x63, 0x76, 0x00,
		0x00, 0x00, 0x04, 0x68, 0x6a, 0x6b, 0x6c, 0x0d, 0x00, 0x41, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x03, 0x66, 0x6f, 0x6f, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0xff, 0x04,
		0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x03, 0x00, 0x00, 0x08,
		0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0b, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x0f,
		0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x09, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x00,
		0x0d, 0x00, 0x41, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	sl := (*rt.GoSlice)(unsafe.Pointer(&buf))
	pos, err := decode(rt.UnpackEface(v).Type, sl.Ptr, sl.Len, 0, unsafe.Pointer(&v), rs, 0)
	require.NoError(t, err)
	require.Equal(t, len(buf), pos)
}

type TestWithDefaultValue struct {
	A int64 `frugal:"0,default,i64"`
	B int64 `frugal:"1,default,i64"`
	C int64 `frugal:"2,default,i64"`
}

func (self *TestWithDefaultValue) InitDefault() {
	*self = TestWithDefaultValue{B: 100}
}

func TestDecoder_WithDefaultValue(t *testing.T) {
	var v TestWithDefaultValue
	rs := new(RuntimeState)
	buf := []byte{0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00}
	sl := (*rt.GoSlice)(unsafe.Pointer(&buf))
	pos, err := decode(rt.UnpackEface(v).Type, sl.Ptr, sl.Len, 0, unsafe.Pointer(&v), rs, 0)
	require.NoError(t, err)
	require.Equal(t, len(buf), pos)
	spew.Dump(v)
}

type TestNoCopyString struct {
	A string  `frugal:"1,default,string"`
	B string  `frugal:"2,default,string,nocopy"`
	C *string `frugal:"3,optional,string,nocopy"`
	D []byte  `frugal:"4,default,binary"`
	E []byte  `frugal:"5,default,binary,nocopy"`
	F *[]byte `frugal:"6,optional,binary,nocopy"`
}

func TestDecoder_NoCopyString(t *testing.T) {
	var v TestNoCopyString
	rs := new(RuntimeState)
	buf := []byte{
		0x0b, 0, 1, 0, 0, 0, 5, 't', 'e', 's', 't', '1',
		0x0b, 0, 2, 0, 0, 0, 5, 't', 'e', 's', 't', '2',
		0x0b, 0, 3, 0, 0, 0, 5, 't', 'e', 's', 't', '3',
		0x0b, 0, 4, 0, 0, 0, 5, 't', 'e', 's', 't', '4',
		0x0b, 0, 5, 0, 0, 0, 5, 't', 'e', 's', 't', '5',
		0x0b, 0, 6, 0, 0, 0, 5, 't', 'e', 's', 't', '6',
		0x00,
	}
	sl := (*rt.GoSlice)(unsafe.Pointer(&buf))
	pos, err := decode(rt.UnpackEface(v).Type, sl.Ptr, sl.Len, 0, unsafe.Pointer(&v), rs, 0)
	require.NoError(t, err)
	require.Equal(t, len(buf), pos)
	require.Equal(t, TestNoCopyString{
		A: "test1",
		B: "test2",
		C: &(&struct{ v string }{"test3"}).v,
		D: []byte("test4"),
		E: []byte("test5"),
		F: &(&struct{ v []byte }{[]byte("test6")}).v,
	}, v)
	println("buf: source =", &buf[0])
	println("v.A: normal =", *(*unsafe.Pointer)(unsafe.Pointer(&v.A)))
	println("v.B: nocopy =", *(*unsafe.Pointer)(unsafe.Pointer(&v.B)))
	println("v.C: nocopy =", *(*unsafe.Pointer)(unsafe.Pointer(v.C)))
	println("v.D: normal =", &v.D[0])
	println("v.E: nocopy =", &v.E[0])
	println("v.F: nocopy =", &(*v.F)[0])
	spew.Dump(v)
}
